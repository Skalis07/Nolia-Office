<!-- ========================================================================================================================================================-->
<!-- ========================================================================================================================================================-->


<!-- Archivo: src/pages/index.astro -->
<!-- Página Astro que funciona en local y en GitHub Pages usando import.meta.env.BASE_URL -->


<!-- ========================================================================================================================================================-->
<!-- ========================================================================================================================================================-->


<!-- Abre la cabecera del documento. -->
<head>
  <!-- Configuración básica de la página -->
  <meta charset="utf-8" /> <!-- Tipo de caracteres: UTF-8 permite tildes, ñ y símbolos -->
  <meta name="color-scheme" content="light only" /> <!-- Para que la página se vea bien aunque fuercen dark mode -->
  <link rel="icon" type="image/svg+xml" href={import.meta.env.BASE_URL + "favicon.svg"} /> <!-- Icono pequeño que se ve en la pestaña del navegador (BASE_URL) -->
  <meta name="viewport" content="width=device-width, initial-scale=1" /> <!-- Hace que la página se adapte a móviles <diseño responsivo> -->
  <meta name="generator" content={Astro.generator} /> <!-- Esto lo agrega Astro automáticamente, indica que se utiliza Astro y su versión-->
  <title>Para mi princesa &lt;3</title> <!-- Texto que se ve en la pestaña del navegador, &lt; es el símbolo "<" -->

  <!-- Bloque de estilos CSS empieza aquí. -->
  <style>

    *, *::before, *::after { box-sizing: border-box; } /* Evita que el padding/border agranden el tamaño real (está principalmente por estándar y buena práctica) */

    :root{
      --frame-max:1200px; /* Ancho base compartido por título y frame */
      --page-pad:10px; /* Padding horizontal/vertical base de la página */
      --color-bg:#2a5b3d; /* Fondo principal */
      --color-text:#000; /* Texto principal */
      --color-white:#fff; /* Blanco base */
      --color-bar:#5aa7a6; /* Barra de música */
      --color-bar-border:rgba(255,255,255,.75); /* Borde de barra */
      --white-65:rgba(255,255,255,.65); /* Blancos con transparencia */
      --white-18:rgba(255,255,255,.18);
      --white-12:rgba(255,255,255,.12);
      --radius-lg:20px; /* Radio grande */
      --radius-pill:9999px; /* Radio tipo pastilla */
      --border-thick:5px; /* Borde grueso */
      --border-btn:3px; /* Borde de botones/bolita */
      --shadow-card:0 4px 15px rgba(0,0,0,.3);
      --shadow-bar:0 4px 12px rgba(0,0,0,.25);
      --shadow-thumb:0 1px 2px rgba(0,0,0,.25);
      --shadow-thumb-lg:0 3px 6px rgba(0,0,0,.25);
      --shadow-handle:inset 0 2px 0 rgba(0,0,0,.08), 0 2px 8px rgba(0,0,0,.15);
      --shadow-handle-hover:inset 0 2px 0 rgba(0,0,0,.1), 0 3px 10px rgba(0,0,0,.2);
      --slider-track-h:6px; /* Alto de la barra del volumen */
      --slider-thumb:16px; /* Tamaño del circulito */
      --bar-pad:10px 16px; /* Padding base de la barra */
      --bar-pad-compact:8px 10px; /* Padding en pantallas chicas/Notion */
      --bar-gap:10px; /* Separación base de íconos */
      --bar-gap-compact:8px; /* Separación compacta */
      --frame-gap:12px; /* Espacio entre GIF y barra */
    }

    .title-wrap{ /* Selector CSS '.title-wrap': aplica a cualquier elemento con esa clase */
      width:100%; /* La caja ocupa todo el ancho disponible de su contenedor padre. */
      max-width:var(--frame-max); /* Ancho máximo */
      margin-inline:auto; /* Centrado para que calce con el frame */
      overflow: visible; /* Permite que el contenido que sobresalga (por ejemplo, un título escalado con transform) siga siendo visible y no se recorte */
      padding-top: 4px; /* Colchón (espacio) superior */
      position: relative; /* Mantiene la posición normal del elemento, pero permite usar desplazamientos (top/left/etc.) */
      z-index: 10; /* Asegura que esta capa quede por encima de otros elementos con z-index menor. En tu página ayuda a que el título no quede tapado por overlays o fondos animados. */
      transition: none; /* Evita animaciones raras: ajuste instantáneo */
      will-change: height; /* Indica al navegador que la altura probablemente cambiará pronto, optimizando el renderizado (mejora el rendimiento de animaciones). */
    }
    
    #pageTitle{ /* Selector CSS '#pageTitle': aplica al elemento con id="pageTitle" (el título principal). */
      display:inline-block; /* Se comporta como elemento en línea pero permite ancho/alto y transform sin ocupar toda la fila. */
      white-space:nowrap; /* Evita que el texto haga saltos de línea: todo el título se mantiene en una sola línea. */
      transform-origin: left top; /* Punto de origen de las transformaciones (scale, etc.) en la esquina superior izquierda del título. */
      line-height:1.15; /* Ajusta el espacio vertical entre líneas para que el título se vea más compacto y legible. */
      font-size: clamp(14px, 4vw, 28px); /* Tamaño de fuente fluido: mínimo 14px, máximo 28px, creciendo según el ancho de la ventana (4vw). */
      transition: none; /* Evita animaciones raras: ajuste instantáneo */
      will-change: transform; /* Le avisa al navegador que 'transform' cambiará, optimizando el renderizado de la animación. */
    }

    /* ===== Página ===== */ /* Sección de estilos generales para la estructura y fondo de la página. */
    html, body{
      margin:0; /* Elimina el margen por defecto del navegador alrededor de la página. */
      overflow-x:hidden; /* Evita que aparezca barra de scroll horizontal si algo se sale un poco por los lados. */
    }
    body{
      text-align:center; /* Centra el texto de forma horizontal por defecto dentro del body. */
      background:var(--color-bg); /* Color de fondo base de la página (verde oscuro). */
    }

    .page{
      background-image:var(--bg-url); /* Patrón directo en la página */
      background-repeat:repeat; /* Repite el mosaico */
      background-position:0 0; /* Ancla el patrón en la esquina superior izquierda */
      background-size:auto; /* Mantiene el tamaño original del tile */

      min-height:100vh; /* La sección .page siempre mide al menos el alto completo de la ventana (viewport). */

      display:flex; /* Usa Flexbox para organizar el contenido interno. */
      flex-direction:column; /* Coloca los elementos hijos en una columna (uno debajo del otro). */
      align-items:center; /* Centra horizontalmente los elementos hijos dentro del contenedor. */

      gap:16px; /* Espacio de 16px entre los elementos hijos (separación vertical en este caso). */
      padding:var(--page-pad) var(--page-pad) 0; /* Relleno: 10px arriba y a los lados, 0 abajo. */
      position:relative; /* Mantiene la posición normal, pero permite posicionar hijos de forma absoluta dentro de .page. */
    }

    /* ===== Título principal ===== */
    h1{
      margin:0; /* Elimina el margen superior e inferior que los <h1> traen por defecto. */
      color:var(--color-text); /* Color del texto: negro. */
      font-family:Arial, sans-serif; /* Usa Arial, o si no existe, otra fuente sans-serif. */
    }

    /* ===== Marco del GIF (Contenedor) ===== */
    .img-redondeada{ /* Contenedor del GIF (o imagen) con bordes redondeados y estilo de tarjeta. */
      max-width:var(--frame-max); /* Limita el ancho máximo para que no se haga demasiado grande en pantallas grandes. */
      width:100%; /* Ocupa el 100% del espacio disponible hasta el máximo. */
      border-radius:var(--radius-lg); /* Esquinas redondeadas del marco. */
      border:var(--border-thick) solid var(--color-white); /* Borde blanco grueso alrededor del GIF. */
      box-shadow:var(--shadow-card); /* Sombra para dar sensación de elevación/3D. */
      overflow:hidden; /* Recorta lo que sobresalga de los bordes redondeados. */
      position:relative; /* Necesario para que elementos hijos (como la fecha) se posicionen de forma absoluta dentro. */
    }

    /* ===== Imagen dentro del marco ===== */
    .img-redondeada img{ /* Imagen interna del marco. */
      display:block; /* Elimina el espacio en blanco de imágenes inline. */
      width:100%; /* La imagen se adapta al ancho del marco. */
      height:auto; /* Mantiene proporción natural del GIF. */
      object-fit:cover; /* La imagen se recorta para llenar el contenedor sin deformarse. */
      object-position:center bottom; /* Enfoque desde el centro hacia abajo (útil si el GIF tiene algo importante en la parte baja). */
      position:relative; z-index:1; /* Se asegura de que quede por debajo del badge de fecha. */
    }

    /* ===== Badge de Fecha (Etiqueta sobre el GIF) ===== */
    .badge-fecha { /* Etiqueta/placa de la fecha que aparece encima del GIF en la esquina inferior izquierda. */
      position: absolute; /* Se posiciona libremente dentro del contenedor (.img-redondeada). */
      left: 0; bottom: 0; /* Ubicación exacta: esquina inferior izquierda. */
      background: none; /* Sin fondo sólido (puede superponerse directamente sobre el GIF). */
      color: var(--color-white); /* Texto blanco para contrastar con el GIF. */

      font-family: "Arial Rounded MT Bold", "Arial Rounded MT", Arial, sans-serif; /* Fuente más amigable y redondeada. */
      font-weight: 900; /* Peso muy grueso: texto fuerte y destacado. */
      font-size: clamp(18px, 5vw, 26px); /* Tamaño adaptable: más grande que antes. */
      line-height: 1.2; /* Altura de línea compacta, mejora la lectura si son dos líneas. */
      letter-spacing: 0.1px; /* Muy leve separación entre caracteres para claridad. */

      padding: 8px 10px; /* Relleno interno: espacio entre borde y texto. */
      border-top-right-radius: 10px; /* Redondea solo la esquina superior derecha (estilo de etiqueta pegada a un borde). */
      text-align: left; /* Alineación del texto. */
      white-space: pre-line; /* Permite saltos de línea si los pones dentro del texto. */
      user-select: none; /* Evita que el usuario pueda seleccionar el texto accidentalmente. */

      z-index: 2; /* Se muestra por encima de la imagen (que está en z-index:1). */
    }

    /* ===== iframes ocultos pero reproducibles (visually-hidden) ===== */
    #yt-audio{
      position: absolute !important; /* Lo saca del flujo normal sin eliminarlo. Necesario para ocultarlo pero mantener audio activo. */
      left: 0 !important; /* Fijado al borde superior izquierdo (común en técnicas de hiding). */
      top: 0 !important;
      width: 1px !important; /* Tamaño mínimo para evitar que el iframe ocupe espacio real. */
      height: 1px !important;
      margin: -1px !important; /* Esto hace que ese “1px” quede fuera de vista visual. */
      padding: 0 !important;
      overflow: hidden !important; /* Evita mostrar contenido interno. */
      opacity: 0 !important; /* Completamente invisible. */
      pointer-events: none !important; /* El usuario no puede interactuar (click, hover). */
      border: 0 !important; /* oculto visualmente sin sacarlo del flujo ni mandarlo offscreen */
      clip: rect(0 0 0 0) !important; /* Método antiguo: recorta todo el elemento. */
      clip-path: inset(50%) !important; /* Método moderno: lo “recorta” visualmente. */
    }

    #yt-audio iframe{
      width: 1px !important; /* El iframe interno también tiene 1px para evitar layout shift. */
      height: 1px !important;
      border: 0 !important;
      display: block !important; /* Evita espacio extra de inline-elements. */
    }

    /* ===== Barra música ===== */
    .barra-musica{
      --turquesa:var(--color-bar); --borde-claro:var(--color-bar-border); /* Variables internas del componente */
      width:100%; margin-inline:auto; /* Centrado y responsivo */
      background:var(--turquesa); /* Color del fondo */
      border:4px solid var(--borde-claro); /* Contorno claro */
      border-radius:var(--radius-pill); /* Bordes súper redondeados (pastilla) */
      padding:var(--bar-pad); /* Separación interna para que no quede apretado. */
      display:flex; align-items:center; justify-content:center; /* Alineación */
      flex-wrap:nowrap; /* Los botones no saltan de línea */
      gap:var(--bar-gap); /* Separación entre items */
      box-shadow:var(--shadow-bar); /* Sombra elegante */
      position:relative; z-index:20; /* Se mantiene sobre otros elementos */
      transition:opacity .2s, filter .2s; /* Animación suave al cambiar de modo oscuro o cuando algo afecte opacity. */
    }

    .oscuro .barra-musica{ 
      opacity:.85; 
      filter:saturate(.75) brightness(.85); /* Tema oscuro */
    }

    .icon-btn{
      width:44px; height:44px; flex:0 0 44px; /* Botón cuadrado, tamaño fijo */
      border-radius:50%; /* Botón redondo */
      border:var(--border-btn) solid var(--color-white); background:transparent; color:var(--color-white); /* Estilo visual del borde + color del icono. */
      display:grid; place-items:center; /* Centrado perfecto del SVG */
      cursor:pointer; /* Manito mouse */
      transition:background-color .2s, transform .05s, opacity .2s; /* Animación suave del hover, active y cualquier cambio de opacidad. */
    }

    .icon-btn:hover{ background-color:var(--white-12); } /* Hover: cuando el mouse pasa encima del botón, se ilumina levemente */
    .icon-btn:active{ transform:scale(.98); } /* Active (pseudo): mientras se hace clic o se mantiene presionado, el botón se “hunde” */
    .icon-btn svg{ width:20px; height:20px; display:block; } /* Tamaño del ícono SVG y display:block evita espacios indeseados */
    .icon-btn.active{ background-color:var(--white-18); } /* Clase .active: estado «encendido» cuando lo activa el JS */

    /* ===== Slider volumen (MÚSICA) ===== */
    .volume-slider{
      -webkit-appearance:none; appearance:none; /* Elimina el estilo por defecto del navegador */
      flex:1 1 160px; /* Se estira, puede reducirse, base 160px: funciona bien en flexbox */
      min-width:0; /* CLAVE para que no rompa el layout dentro de flex */
      max-width:320px; /* En pantallas grandes crece hasta 320px */
      height:var(--slider-track-h); border-radius:var(--radius-pill); /* Barra larga, muy redondeada */
      background:var(--white-65); /* Color de la barra */
      outline:none; /* Elimina contorno feo al enfocarse */
      cursor:pointer; /* Manito para indicar que es interactivo */
    }

    /* Thumb (punto que se arrastra) */
    .volume-slider::-webkit-slider-thumb{
      -webkit-appearance:none; appearance:none; /* Elimina estilo por defecto */
      width:var(--slider-thumb); height:var(--slider-thumb); border-radius:50%; background:var(--color-white); /* Circulito blanco */
      border:2px solid var(--turquesa); /* Borde del color del tema */
      box-shadow:var(--shadow-thumb); /* Sombra ligera */
    }

    /* Thumb — Firefox */
    .volume-slider::-moz-range-thumb{
      width:var(--slider-thumb); height:var(--slider-thumb); border-radius:50%; background:var(--color-white);
      border:2px solid var(--turquesa); box-shadow:var(--shadow-thumb);
    }
    
    /* Track — Firefox */
    .volume-slider::-moz-range-track{
      height:var(--slider-track-h); border-radius:var(--radius-pill); background:var(--white-65);
    }

    /* ======= Tirita sol/luna ======= */

    /* Animación de “estirarse” de la barra al hacer clic */
    @keyframes stretch{ 
      0%{transform:translateZ(0) scaleY(1)} 
      50%{transform:translateZ(0) scaleY(1.06)} /* Se estira un poquito */
      100%{transform:translateZ(0) scaleY(1)} 
    }

    /* Contenedor principal fijo al lado derecho */
    .right-handle{ 
      --thumb:34px; --strip-h:220px; /* Variables: tamaño del botón y altura de la tirita */
      position:fixed; /* Siempre visible en pantalla */
      top:0; right:16px; /* Arriba a la derecha */
      z-index:30; /* Sobre casi todo lo demás */
      pointer-events:none; /* El contenedor no recibe clics, solo sus hijos */
      display:flex; align-items:flex-start; justify-content:center; /* Alineación vertical */
    }
    
    /* Barra vertical (la tirita) */
    .right-handle .track{
      position:relative; 
      width:24px; height:var(--strip-h); /* Altura controlada por la variable */
      background:#fff9e8; /* Color crema */
      border-radius:0; 
      margin-bottom:calc(var(--thumb)*.5); /* Espacio para que el botón no se corte */
      box-shadow:var(--shadow-handle); /* Sombras dobles */
      pointer-events:auto; /* Esta parte sí recibe clics */
      transform-origin:top center; /* Punto de origen para la animación stretch */
      cursor:pointer; 
      transition:box-shadow .18s, background .18s; /* Cambio suave al pasar el mouse */
    }

    /* Hover en la barra */
    .right-handle .track:hover{ 
      background:#fff4d1; /* Más clarito */
      box-shadow:var(--shadow-handle-hover); 
    }

    /* Cuando se activa la animación stretch */
    .right-handle .track.stretch{ 
      animation:stretch 220ms ease-out; 
    }

    /* Botón circular (sol/luna) */
    .right-handle .thumb{
      position:absolute; 
      left:50%; transform:translateX(-50%); /* Centrado horizontal */
      width:var(--thumb); height:var(--thumb); /* Tamaño según variable */
      border-radius:50%; /* Perfectamente redondo */
      border:var(--border-btn) solid var(--color-white); 
      display:grid; place-items:center; /* Centra el ícono SVG */
      bottom:calc(-1 * var(--thumb) * .5); /* Sale “medio afuera” de la tirita */
      transition:background 160ms, color 160ms, box-shadow 160ms, transform 80ms; /* Animaciones */
      cursor:pointer; 
      color:#6b4a00; background:#ffc400; /* Color de “sol” */
      box-shadow:var(--shadow-thumb-lg);
      pointer-events:auto; /* Sí recibe clics */
    }
    
    /* Hover del botón (crece apenas) */
    .right-handle .thumb:hover{ 
      transform:translateX(-50%) scale(1.03); 
    }

    /* Ícono dentro del botón */
    .right-handle .thumb svg{ 
      width:18px; height:18px; display:block; 
    }

    /* Estado “modo oscuro” (cuando la clase .activo está activada) */
    .right-handle.activo .thumb{ 
      background:#2e2e2e; /* Fondo oscuro */
      color:var(--color-white); /* Ícono blanco */
    }

    /* ===== Oscurecido ===== */
    .dim-overlay{ 
      position:fixed; /* Cubre toda la pantalla aunque haya scroll */
      inset:0; /* Atajo para top:0; right:0; bottom:0; left:0 */
      background:rgba(0,0,0,.45); /* Capa oscura semitransparente */
      opacity:0; /* Inicialmente invisible */
      visibility:hidden; /* No recibe clics cuando está oculto */
      transition:opacity 160ms, visibility 160ms; /* Fade suave */
      z-index:25; /* Debajo de la tirita (z=30), encima del resto */
      pointer-events:none; /* No bloquea clics a menos que se active */
    }

    /* Cuando el overlay está activo, aparece */
    .dim-overlay.activo{ 
      opacity:1; 
      visibility:visible; 
    }

    /* ===== Frame: mismo ancho para GIF y barra ===== */
    .frame{ 
      width:100%; 
      max-width:var(--frame-max); /* Límite de ancho */
      margin-inline:auto; /* Centrado */
    }

    /* ===== Fullscreen (F11 / Fullscreen API) ===== */
    html.browser-fullscreen{
      --frame-max:min(1400px, 92vw); /* Expansión suave solo en fullscreen */
    }

    /* Asegura que GIF y barra tengan el mismo ancho */
    .frame .img-redondeada, 
    .frame .barra-musica{ 
      width:100%; 
      max-width:none; 
    }

    /* --- separación entre GIF y barra (página y Notion) --- */
    .frame .barra-musica{
      margin-top: var(--frame-gap); /* espacio extra debajo del GIF */
    }

    /* En embeds de Notion — a veces hay CSS que pisa el tuyo */
    html.embed-notion .barra-musica{
      margin-top: var(--frame-gap) !important; /* Se fuerza para evitar bugs */
    }

    /* ===== Ajustes móviles generales ===== */
    @media (max-width:520px){

      .barra-musica{ 
        padding:var(--bar-pad-compact); /* Menos padding para pantallas pequeñas */
        gap:var(--bar-gap-compact); /* Menor separación entre íconos */
      }

      .icon-btn{ 
        width:36px; height:36px; flex-basis:36px; /* Botones más pequeños */
      }

      .volume-slider{ 
        min-width:0; 
        max-width:none; /* Permite que el slider se ajuste en móviles */
      }

      .volume-slider::-webkit-slider-thumb{ 
        width:12px; height:12px; /* Thumb más pequeño */
      }

      .volume-slider::-moz-range-thumb{ 
        width:12px; height:12px; 
      }

      /* --- Alto tipo “vertical” en móviles --- */
      .frame .img-redondeada{
        height: 72vh;       /* Ocupa ~72% del alto visible del móvil */
        max-height: 80vh;   /* Evita que sea demasiado grande */
        width: 100%;
      }

      .frame .img-redondeada img{
        width: 100%;
        height: 100%;
        object-fit: cover;  /* Imagen recortada, bien centrada */
        object-position: center bottom;
      }
    }

    /* ===== Ajustes móviles extra (pantallas muy pequeñas) ===== */
    @media (max-width:380px){
      .page{ padding:8px 8px 0; } /* Reduce padding general para pantallas súper chicas */
      .right-handle{ right:8px; --strip-h:160px; } /* Acerca la tirita y la hace más corta */
      .icon-btn{ width:40px; height:40px; } /* Botones un poco más pequeños */
      .volume-slider::-webkit-slider-thumb{ width:14px; height:14px; } /* Thumb más chico en Chrome/Opera */
      .volume-slider::-moz-range-thumb{ width:14px; height:14px; } /* Thumb más chico en Firefox */
    }

    /* En pantallas ultrapequeñas (celulares mini), oculta la tirita */
    @media (max-width:320px){ 
      .right-handle{ display:none; } /* Evita que tape contenido */
    }

    /* ===== Notion embed: limpio y sin cortes ===== */

    /* Quita fondo en Notion (su iframe ya maneja su propio fondo) */
    html.embed-notion, 
    html.embed-notion body{ 
      background:transparent!important; 
    }

    /* Quita fondo, padding y otras propiedades de la página */
    html.embed-notion .page{ 
      --bg-url:none!important; 
      background:transparent!important; 
      padding:0!important; 
    }

    /* Oculta el título en Notion */
    html.embed-notion .title-wrap{ 
      display:none!important; 
    }

    /* Oculta tirita y overlay en Notion (no sirven dentro del iframe) */
    html.embed-notion .right-handle, 
    html.embed-notion .dim-overlay{ 
      display:none!important; 
    }

    /* Asegura que el frame se adapte a Notion sin cortes */
    html.embed-notion .frame{ 
      display:block!important; 
      max-width:100%!important; 
      min-width:0!important; 
    }

    /* Quita bordes y sombras que se ven mal en el embed */
    html.embed-notion .img-redondeada,
    html.embed-notion .barra-musica{ 
      border:0!important; 
    }

    html.embed-notion .img-redondeada{ 
      border-radius:var(--radius-lg)!important; 
    }

    /* Extra: evita sombras en Notion */
    html.embed-notion .img-redondeada, 
    html.embed-notion .barra-musica, 
    html.embed-notion .icon-btn{ 
      box-shadow:none!important; 
    }

    /* La barra NO se debe cortar: permite que pase a 2 filas */
    html.embed-notion .barra-musica{
      flex-wrap:wrap!important; /* Permite salto a otra línea */
      padding:var(--bar-pad-compact)!important; /* Más compacto */
      gap:var(--bar-gap-compact)!important; /* Menos separación */
      min-width:0!important; /* Previene cortes raros con flex */
    }

    /* Orden y comportamiento responsive de los controles dentro de Notion */
    html.embed-notion .volume-slider{
      order:2!important;            /* El slider pasa a la segunda fila (abajo) en Notion */
      flex:1 1 100%!important;      /* Puede crecer y ocupar el 100% del ancho disponible */
      width:100%!important;         /* Asegura que ocupe toda la fila */
      max-width:none!important;     /* Evita límites de ancho heredados */
      min-width:0!important;        /* Previene cortes raros con flexbox */
      transform:none!important;     /* Desactiva cualquier transformación aplicada fuera de Notion */
    }

    /* Botones (play/pause, lluvia, GIF shuffle) → se ordenan arriba */
    html.embed-notion #musicToggle,
    html.embed-notion #rainToggle,
    html.embed-notion #gifShuffle{ 
      order:1!important;            /* Todos los botones se alinean en la primera fila */
    }

  </style>

  <!-- ===== Script: Detecta si está embebido en Notion ===== -->
  <script is:inline>
      (function(){
        const qs = new URLSearchParams(location.search); 
        /* Lee los parámetros de la URL (ej: ?notion=1) */

        const inIframe = (()=>{ 
          try{ 
            return window.self !== window.top 
          }catch(_){ 
            return true 
          }
        })();
        /* Detecta si la página está dentro de un iframe.
          - window.self === window.top → NO está embebido.
          - window.self !== window.top → Está en un iframe.
          El try/catch es por si el iframe está en dominio distinto y lanza error. */

        const isNotion = 
          qs.has('notion') || 
          /notion\.so|notion\.site/i.test(document.referrer || '');
        /* Detecta si el embed proviene de Notion:
          1) ?notion en la URL
          2) El referrer contiene "notion.so" o "notion.site"
          (cuando Notion inserta tu página como embed) */

        if(inIframe && isNotion){
          document.documentElement.classList.add('embed-notion');
        }
        /* Si está dentro de un iframe Y es Notion → 
          agrega la clase <html class="embed-notion"> 
          para activar todos los estilos especiales CSS que creaste. */
      })();
  </script>

  
<!-- ===== Script: Detecta fullscreen del navegador (F11) ===== -->
<script is:inline>
  (function(){
    /* IIFE (Immediately Invoked Function Expression)
       - Se ejecuta inmediatamente al cargarse el script.
       - Evita contaminar el scope global (no crea variables globales innecesarias). */

    const root = document.documentElement;
    /* document.documentElement === <html>
       - Guardamos el elemento raíz para poder agregar/quitar clases CSS. */

    const threshold = 8; // px de tolerancia
    /* Umbral de tolerancia en píxeles:
       - A veces el tamaño de la ventana no coincide EXACTO con screen.width/screen.height
         (por barras, scroll, zoom, o comportamiento del navegador).
       - Por eso usamos ±8px como margen de error. */

    function isDesktop() {
      /* Detecta si estamos en un entorno "desktop real":
         - (hover: hover) => el dispositivo permite hover (mouse)
         - (pointer: fine) => puntero preciso (mouse)
         Esto ayuda a evitar falsos positivos en móviles/tablets. */
      return window.matchMedia('(hover: hover) and (pointer: fine)').matches;
    }

    function detectFullscreen() {

      /* Si estamos embebidos en Notion (iframe), no aplicamos fullscreen.
         - embed-notion se añade por tu otro script de detección de Notion.
         - Dentro de iframes fullscreen normalmente no aplica o no tiene sentido. */
      if (root.classList.contains('embed-notion')) return;

      /* 1) Fullscreen API real:
         - document.fullscreenElement es distinto de null cuando
           un elemento entró a fullscreen usando requestFullscreen().
         - Esto NO siempre ocurre con F11. */
      const apiFullscreen = !!document.fullscreenElement;

      /* 2) Fullscreen por F11 (modo “casi pantalla completa”)
         - F11 muchas veces no activa Fullscreen API.
         - Entonces detectamos si el tamaño de la ventana ≈ tamaño real de pantalla.
         - Si coincide (dentro del threshold), asumimos fullscreen. */
      const nearScreen =
        Math.abs(window.innerWidth - screen.width) <= threshold &&
        Math.abs(window.innerHeight - screen.height) <= threshold;

      /* Fullscreen activo si:
         - Hay fullscreen por API, o
         - estamos en desktop y la ventana ocupa prácticamente toda la pantalla (F11). */
      const active = apiFullscreen || (isDesktop() && nearScreen);

      /* Agrega o quita la clase en <html>:
         - Si active === true => <html class="browser-fullscreen">
         - Si active === false => se elimina la clase
         
         Esta clase activa tu CSS:
         html.browser-fullscreen { --frame-max: ... } */
      root.classList.toggle('browser-fullscreen', active);
    }

    /* Cuando se cambia el tamaño de la ventana (incluye entrar/salir F11),
       se recalcula si estamos en fullscreen.
       passive:true = mejora performance porque el listener no bloquea scroll */
    window.addEventListener('resize', detectFullscreen, { passive: true });

    /* Cuando cambia el fullscreen usando Fullscreen API (requestFullscreen / exitFullscreen),
       se vuelve a detectar */
    document.addEventListener('fullscreenchange', detectFullscreen);

    /* Al cargar la página por primera vez, detecta el estado inicial */
    window.addEventListener('load', detectFullscreen, { once: true });

  })();
</script>


</head>


<!-- ========================================================================================================================================================-->
<!-- ========================================================================================================================================================-->


<!-- NOTA: En Astro, no se añade <html> ni <body> explícitos. El contenido de la página va directo aquí. -->

<!-- ===========================================================================
     CONTENEDOR GENERAL DE LA PÁGINA
     - Funciona como "wrapper" vertical que organiza todo el contenido.
     - Se define la variable CSS --bg-url para el fondo (compatible con BASE_URL).
     =========================================================================== -->
<!-- Contenedor principal de todo el contenido visible de la página -->
<div class="page" 
     data-base={import.meta.env.BASE_URL}
     style={`--bg-url: url(${import.meta.env.BASE_URL}fondo.png)`}>

  <!-- =======================================================================
       TÍTULO PRINCIPAL
       - El contenedor controla padding, animaciones y escalado dinámico.
       ======================================================================= -->
  <!-- Contenedor del título, usado por CSS para manejar altura, padding y animación -->
  <div class="title-wrap">
    <!-- Título principal de la página, con id para estilos y JS (auto-escalado) -->
    <h1 id="pageTitle">
      <!-- Texto que se muestra como título grande arriba de todo -->
      NOELIA ESTOY HACIENDO MI PÁGINA WEB QUÉ EMOCIÓN BUENO Y AHORA QUÉ HAGO
    </h1>
  </div>

  <!-- =======================================================================
       FRAME (AGRUPA EL GIF + BARRA DE MÚSICA)
       - Mantiene ancho máximo y alinea todo al centro.
       ======================================================================= -->
  <!-- Frame: agrupa el bloque del GIF y la barra de controles en un mismo ancho -->
  <div class="frame">

    <!-- =====================================================================
         CONTENEDOR DEL GIF
         - Marco redondeado, sombra, y elementos superpuestos (reloj, audio).
         ===================================================================== -->
    <!-- Contenedor con marco redondeado y sombra donde va el GIF y overlays -->
    <div class="img-redondeada">

      <!-- Imagen principal (GIF) -->
      <!-- id="mainGif": lo usa JS para cambiar de GIF y bloquear proporción -->
      <!-- src: usa BASE_URL para encontrar correctamente 1.gif en local y GitHub Pages -->
      <!-- alt: texto alternativo para accesibilidad -->
      <img id="mainGif"
           src={import.meta.env.BASE_URL + "1.gif"}
           alt="Gif en el centro">

      <!-- Reloj / fecha superpuesto (actualizado por JS) -->
      <!-- id="reloj": JS escribe aquí la fecha y hora -->
      <!-- class="badge-fecha": estilos de la etiqueta pegada abajo a la izquierda -->
      <!-- aria-live="polite": permite que lectores de pantalla anuncien los cambios sin interrumpir -->
      <div id="reloj" class="badge-fecha" aria-live="polite"></div>

      <!-- Reproductor de YouTube oculto para la música -->
      <!-- id="yt-audio": contenedor invisible que mantiene el iframe de YouTube fuera de la vista -->
      <!-- aria-hidden="true": se marca como irrelevante para accesibilidad -->
      <div id="yt-audio" aria-hidden="true">
        <!-- Aquí la API de YouTube inserta el <iframe> del reproductor -->
        <div id="ytplayerMusic"></div>
      </div>

      <!-- Audio local de lluvia controlado por JavaScript -->
      <!-- id="rainAudio": el JS lo usa para reproducir/pausar lluvia -->
      <!-- src: ruta al archivo rain.mp3 usando BASE_URL -->
      <!-- preload="auto": intenta cargar el audio por adelantado -->
      <!-- loop: reproduce en bucle continuamente -->
      <audio id="rainAudio"
             src={import.meta.env.BASE_URL + "rain.mp3"}
             preload="auto"
             loop></audio>
    </div> <!-- /.img-redondeada -->

    <!-- =====================================================================
         BARRA DE CONTROL (MÚSICA, VOLUMEN, LLUVIA, CAMBIAR GIF)
         ===================================================================== -->
    <!-- Barra horizontal con los controles de música, volumen, lluvia y cambio de GIF -->
    <!-- id="controlsBar": usado por CSS/JS para referirse a toda la barra -->
    <div class="barra-musica" id="controlsBar">

      <!-- Botón Play/Pause de la música -->
      <!-- id="musicToggle": JS engancha aquí el evento para reproducir/pausar -->
      <!-- class="icon-btn": estilos comunes de botones redondos con icono -->
      <!-- aria-label: descripción accesible del botón para lectores de pantalla -->
      <button id="musicToggle" class="icon-btn" type="button" aria-label="Reproducir música">
        <!-- Icono SVG de "play" (triángulo) -->
        <!-- fill="currentColor": el icono hereda el color del botón -->
        <!-- aria-hidden="true": el SVG es decorativo, la accesibilidad la da aria-label -->
        <svg viewBox="0 0 24 24" fill="currentColor" aria-hidden="true">
          <path d="M8 5v14l11-7z"/>
        </svg>
      </button>

      <!-- Slider del volumen de la música -->
      <!-- id="volumeMusic": JS lee y modifica este control para el volumen de YouTube -->
      <!-- class="volume-slider": estilos personalizados del input range -->
      <!-- type="range": deslizable horizontal -->
      <!-- min/max/value: volumen 0–100, valor inicial 100 -->
      <!-- aria-label: texto accesible para describir el control -->
      <input id="volumeMusic" class="volume-slider" type="range"
             min="0" max="100" value="100"
             aria-label="Volumen de música (0 a 100)" />

      <!-- Botón lluvia -->
      <!-- id="rainToggle": JS lo usa para encender/apagar el sonido de lluvia -->
      <!-- class="icon-btn": mismo estilo redondo que los otros botones -->
      <!-- aria-label: descripción accesible -->
      <!-- title: tooltip que aparece al pasar el mouse por encima -->
      <button id="rainToggle" class="icon-btn" type="button" aria-label="Activar lluvia" title="Lluvia">
        <!-- Icono SVG de nube (estado lluvia desactivada por defecto) -->
        <svg viewBox="0 0 24 24" fill="currentColor" aria-hidden="true">
          <path d="M19 18a4 4 0 0 0 0-8 5 5 0 0 0-9-2 4 4 0 0 0-2 7.5"></path>
        </svg>
      </button>

      <!-- Botón cambiar GIF -->
      <!-- id="gifShuffle": JS lo usa para pasar al siguiente GIF disponible -->
      <!-- title: tooltip "Cambiar GIF" -->
      <button id="gifShuffle" class="icon-btn" type="button" aria-label="Cambiar GIF" title="Cambiar GIF">
        <!-- Icono SVG que representa "cambio" o "siguiente" (flechas) -->
        <svg viewBox="0 0 24 24" fill="currentColor" aria-hidden="true">
          <path d="M4 4h4l4 6-4 6H4l4-6-4-6zm10 0h6v2h-4v4h-2V4zm0 16v-6h2v4h4v2h-6z"/>
        </svg>
      </button>

    </div> <!-- /.barra-musica -->

  </div> <!-- /.frame -->

</div> <!-- /.page -->


<!-- ===========================================================================
     TIRITA SOL / LUNA (MODO DÍA / NOCHE)
     - Control visual fijo al costado derecho de la pantalla.
     - Permite alternar entre modo claro y modo oscuro.
     =========================================================================== -->

<!-- Contenedor principal de la tirita -->
<!-- id="rightHandle": usado por JS para aplicar estados (activo/inactivo) -->
<!-- class="right-handle": estilos de posición fija, altura y animaciones -->
<!-- aria-hidden="false": el control es visible y accesible -->
<div id="rightHandle" class="right-handle" aria-hidden="false">

  <!-- Barra vertical interactiva (riel de la tirita) -->
  <!-- id="rightTrack": JS escucha clics aquí para alternar el modo -->
  <!-- class="track": estilos del riel (color, sombra, animación stretch) -->
  <!-- role="presentation": indica que es decorativo/estructural -->
  <!-- title: tooltip al pasar el mouse -->
  <div id="rightTrack" class="track"
       role="presentation"
       title="Click para atenuar/encender">

    <!-- Botón redondo que representa Sol / Luna -->
    <!-- id="modeThumb": JS cambia el icono y estado -->
    <!-- class="thumb": estilos de la bolita (color, sombra, hover) -->
    <!-- aria-label: descripción accesible del control -->
    <!-- aria-pressed: indica estado activado/desactivado (día/noche) -->
    <button id="modeThumb" class="thumb" type="button" aria-label="Cambiar modo (día/noche)" aria-pressed="false"></button>
  </div>
</div>


<!-- ===========================================================================
     CAPA DE OSCURECIDO (OVERLAY)
     - Se muestra encima del contenido cuando el modo noche está activo.
     - Oscurece visualmente sin bloquear la interfaz.
     =========================================================================== -->

<!-- id="dimOverlay": JS activa/desactiva la clase .activo -->
<!-- class="dim-overlay": estilos de posición fija y transición de opacidad -->
<!-- aria-hidden="true": no es relevante para lectores de pantalla -->
<div id="dimOverlay" class="dim-overlay" aria-hidden="true"></div>


<!-- ===========================================================================
     SCRIPT: FECHA Y HORA
     - Actualiza dinámicamente el contenido del elemento #reloj.
     - Usa el idioma del navegador.
     - Se ejecuta de forma aislada (IIFE).
     =========================================================================== -->
<script is:inline>
    (function() { 
      /* IIFE (Immediately Invoked Function Expression)
         - Se ejecuta inmediatamente.
         - Evita contaminar el scope global. */

      // Busca el elemento donde se mostrará la fecha y la hora
      const $reloj = document.getElementById('reloj');

      // Si el elemento no existe (por ejemplo en un embed), se aborta sin error
      if (!$reloj) return;

      // Idioma del navegador (ej: 'es-CL', 'es-ES', 'en-US')
      // Fallback a 'es-ES' si no se puede detectar
      const locale = navigator.language || 'es-ES';

      // Función que construye y escribe la fecha/hora
      function actualizarReloj() {

        // Fecha y hora actuales
        const ahora = new Date();

        // Formato de fecha largo y legible
        // Ejemplo: "domingo, 10 de agosto de 2025"
        const fecha = ahora.toLocaleDateString(locale, {
          weekday: 'long',
          day: 'numeric',
          month: 'long',
          year: 'numeric'
        });

        // Formato de hora
        // Ejemplo: "20:10" o "08:10 p. m."
        const hora = ahora.toLocaleTimeString(locale, {
          hour: '2-digit',
          minute: '2-digit'
        });

        // Inserta el texto en dos líneas
        // CSS usa white-space: pre-line para respetar el salto
        $reloj.textContent = `${fecha}\n${hora}`;
      }

      // Primera ejecución inmediata (no espera al intervalo)
      actualizarReloj();

      // Actualiza cada 30 segundos (suficiente para minutos)
      setInterval(actualizarReloj, 1000 * 30);

    })();
</script>


<!-- ===========================================================================
     SCRIPT: MÚSICA (YouTube) + LLUVIA (MP3) + LÓGICA DE INTERFAZ
     - Maneja reproducción de música vía YouTube embebido (solo audio).
     - Controla sonido de lluvia con <audio>.
     - Cambia iconos y estados de botones.
     =========================================================================== -->
<script is:inline>

    /* ---------------------------------------------------------------------------
       VOLUMEN POR DEFECTO DE LA LLUVIA
       - Valor en porcentaje (0–100).
       - Se convierte luego a rango 0.0–1.0 para el elemento <audio>.
       --------------------------------------------------------------------------- */
    const DEFAULT_RAIN_VOL = 60; // mismo 60% que usa el slider visual

    /* ---------------------------------------------------------------------------
      BASE_URL (Astro) - helper ÚNICO para rutas (local + GitHub Pages)
      - Usa data-base={import.meta.env.BASE_URL} que ya pusiste en <div class="page">
      - asset("x.png") => URL absoluta correcta, incluso si el sitio vive en /Nolia-Office/
      --------------------------------------------------------------------------- */
    const baseRaw = document.querySelector('.page')?.dataset.base || '/'; // BASE desde Astro (fallback "/")
    const BASE = baseRaw.endsWith('/') ? baseRaw : baseRaw + '/';         // Asegura slash final
    const asset = (path) =>                                               // Helper para assets
      new URL(String(path).replace(/^\//, ''), location.origin + BASE).href;

    /* ===========================================================================
       ICONOS SVG DEFINIDOS COMO STRINGS
       - Se inyectan dinámicamente en los botones con innerHTML.
       - Evita tener múltiples SVG duplicados en el HTML.
       =========================================================================== */

    /* Icono PLAY (reproducir música) */
    const ICON_PLAY =
      '<svg viewBox="0 0 24 24" fill="currentColor" aria-hidden="true">' +
        '<path d="M8 5v14l11-7z"/>' +
      '</svg>';

    /* Icono PAUSE (pausar música) */
    const ICON_PAUSE =
      '<svg viewBox="0 0 24 24" fill="currentColor" aria-hidden="true">' +
        '<path d="M6 5h4v14H6zM14 5h4v14h-4z"/>' +
      '</svg>';

    /* Icono nube SIN lluvia (estado inactivo) */
    const ICON_CLOUD = `
      <svg viewBox="0 0 24 24" fill="currentColor" aria-hidden="true">
        <path d="M19 18a4 4 0 0 0 0-8
                 5 5 0 0 0-9-2
                 4 4 0 0 0-2 7.5"/>
      </svg>`;

    /* Icono nube CON lluvia (estado activo) */
    const ICON_CLOUD_RAIN = `
      <svg viewBox="0 0 24 24" fill="currentColor" aria-hidden="true">
        <path d="M19 18a4 4 0 0 0 0-8
                 5 5 0 0 0-9-2
                 4 4 0 0 0-2 7.5"/>
        <!-- Gotas de lluvia -->
        <path d="M8 20l1-2
                 M12 20l1-2
                 M16 20l1-2"
              stroke="currentColor"
              stroke-width="2"
              stroke-linecap="round"
              fill="none"/>
      </svg>`;


    /* ===========================================================================
       VARIABLES DE ESTADO (MÚSICA Y LLUVIA)
       =========================================================================== */

    let playerMusic;           // Instancia del reproductor YouTube (solo audio)
    let isMusicPlaying = false; // Estado de reproducción de música
    let isRainPlaying  = false; // Estado del sonido de lluvia
    let rainAudio;             // Referencia al elemento <audio> de lluvia

    /* ===========================================================================
       REFERENCIAS A ELEMENTOS DEL DOM
       - Se asignan una sola vez cuando el player está listo.
       =========================================================================== */
    let btnMusic;    // Botón play/pause
    let btnRain;     // Botón lluvia
    let volMusic;    // Slider de volumen
    let btnShuffle;  // Botón cambiar GIF
    let gifImg;      // Imagen del GIF principal

    /* ===========================================================================
       CARGA DINÁMICA DE LA API DE YOUTUBE
       - Inserta el script oficial de YouTube IFrame API.
       - Necesario para crear YT.Player.
       =========================================================================== */

    const ytScript = document.createElement('script'); // Crea <script>
    ytScript.src = 'https://www.youtube.com/iframe_api'; // API oficial
    document.head.appendChild(ytScript); // Se agrega al <head>

    /* ===========================================================================
       CALLBACK GLOBAL REQUERIDO POR YOUTUBE
       - YouTube llama automáticamente a esta función cuando la API está lista.
       =========================================================================== */
    window.onYouTubeIframeAPIReady = function () {

      /* Crear reproductor de YouTube SOLO PARA AUDIO */
      playerMusic = new YT.Player('ytplayerMusic', {
        videoId: '8kBlKM71pjc', // ID del video de YouTube (música)
        playerVars: {
          autoplay: 0,   // No reproducir automáticamente
          controls: 0,   // Ocultar controles nativos
          rel: 0,        // No mostrar videos relacionados
          playsinline: 1 // Reproducir inline en móviles
        },
        events: {
          onReady: onPlayersReady // Se dispara cuando el player está listo
        }
      });
    };


    /* ===========================================================================
       CALLBACK: onPlayersReady
       - Se ejecuta cuando el reproductor de YouTube queda listo.
       - Aplica volúmenes iniciales.
       - Conecta (una sola vez) los controles de la UI.
       - Inicializa helpers del GIF.
       =========================================================================== */
    function onPlayersReady() {

      /* -------------------------------------------------------------------------
         1) APLICAR SIEMPRE EL VOLUMEN ACTUAL AL PLAYER DE YOUTUBE
         - Esto se ejecuta cada vez que algún player “ready-ea”.
         - Se protege con try/catch para evitar errores silenciosos.
         ------------------------------------------------------------------------- */
      try {
        const volEl = document.getElementById('volumeMusic'); // Slider de volumen
        const volValue = volEl ? Number(volEl.value) : 100;   // Fallback a 100%

        // Verifica que el player exista y tenga el método setVolume
        if (playerMusic && typeof playerMusic.setVolume === 'function') {
          playerMusic.setVolume(volValue); // Aplica volumen a YouTube
        }
      } catch (e) {
        // Error ignorado intencionalmente (no rompe la UI si algo falla)
      }

      /* -------------------------------------------------------------------------
         2) VOLUMEN INICIAL DEL AUDIO LOCAL DE LLUVIA
         - Se convierte el porcentaje (0–100) a rango 0.0–1.0.
         ------------------------------------------------------------------------- */
      rainAudio = document.getElementById('rainAudio'); // <audio> de lluvia
      if (rainAudio) {
        rainAudio.volume = DEFAULT_RAIN_VOL / 100; // Ej: 60 → 0.6
      }

      /* -------------------------------------------------------------------------
         3) EVITAR REGISTRAR EVENTOS MÁS DE UNA VEZ
         - Si btnMusic ya existe, significa que el wiring ya ocurrió.
         - Previene listeners duplicados si YouTube re-inicializa el player.
         ------------------------------------------------------------------------- */

         if (btnMusic) return;

      /* -------------------------------------------------------------------------
         4) CACHEAR REFERENCIAS AL DOM (UNA SOLA VEZ)
         - Mejora performance y claridad.
         ------------------------------------------------------------------------- */
      btnMusic   = document.getElementById('musicToggle'); // Botón música
      btnRain    = document.getElementById('rainToggle');  // Botón lluvia
      volMusic   = document.getElementById('volumeMusic'); // Slider volumen
      btnShuffle = document.getElementById('gifShuffle');  // Botón cambiar GIF
      gifImg     = document.getElementById('mainGif');     // Imagen principal GIF

      // Guardia: evita crash si algún elemento falta (IDs cambiados, embed, etc.)
      if (!btnMusic || !btnRain || !volMusic || !btnShuffle || !gifImg) return;

      /* -------------------------------------------------------------------------
         HELPERS DE ESTADO (UI)
         - Centraliza cambios de icono/aria/estado sin tocar la lógica.
         ------------------------------------------------------------------------- */
      function setMusicState(playing) {
        btnMusic.innerHTML = playing ? ICON_PAUSE : ICON_PLAY;
        btnMusic.setAttribute('aria-label', playing ? 'Pausar música' : 'Reproducir música');
        isMusicPlaying = playing;
      }

      function setRainState(playing) {
        if (playing) {
          btnRain.classList.add('active');
          btnRain.innerHTML = ICON_CLOUD_RAIN;
          btnRain.setAttribute('aria-label','Apagar lluvia');
        } else {
          btnRain.classList.remove('active');
          btnRain.innerHTML = ICON_CLOUD;
          btnRain.setAttribute('aria-label','Activar lluvia');
        }
        isRainPlaying = playing;
      }


      /* ===========================================================================
         EVENTOS DE INTERFAZ
         =========================================================================== */

      /* -------------------------------------------------------------------------
         BOTÓN PLAY / PAUSE DE LA MÚSICA (YouTube)
         ------------------------------------------------------------------------- */
      btnMusic.addEventListener('click', () => {
        if (!isMusicPlaying) {
          playerMusic.playVideo();                          // Reproduce música
          setMusicState(true);                              // Actualiza estado/UI
        } else {
          playerMusic.pauseVideo();                         // Pausa música
          setMusicState(false);
        }
      });

      /* -------------------------------------------------------------------------
         SLIDER DE VOLUMEN DE LA MÚSICA (YouTube)
         - Se ejecuta mientras el usuario arrastra el control.
         ------------------------------------------------------------------------- */
      volMusic.addEventListener('input', () => {
        if (playerMusic && typeof playerMusic.setVolume === 'function') {
          playerMusic.setVolume(Number(volMusic.value)); // Aplica nuevo volumen
        }
      });

      /* -------------------------------------------------------------------------
         BOTÓN DE LLUVIA (AUDIO LOCAL)
         - Play / Pause del sonido ambiental.
         - Cambia icono, clase y aria-label.
         ------------------------------------------------------------------------- */
      btnRain.addEventListener('click', () => {
        if (!rainAudio) return; // Seguridad: si no existe, no hacemos nada

        if (!isRainPlaying) {
          // En móviles, el primer play requiere gesto del usuario (este click)
          rainAudio.currentTime = 0;            // (Opcional) reinicia audio
          rainAudio.play();                     // Reproduce lluvia
          setRainState(true);                   // Actualiza estado/UI
        } else {
          rainAudio.pause();                    // Pausa lluvia
          setRainState(false);
        }
      });

      /* -------------------------------------------------------------------------
         INICIALIZACIONES FINALES
         - Bloquea proporción del contenedor según el GIF.
         - Activa el rotador de GIFs.
         ------------------------------------------------------------------------- */
      lockAspectFrom(gifImg);                   // Fija aspect-ratio inicial
      setupGifRotator(btnShuffle, gifImg);      // Habilita cambio de GIFs
    }


    /* ===========================================================================
     MODO OSCURITO (TIRITA SOL / LUNA)
     - Controla el cambio entre modo día y modo noche.
     - Usa una “tirita” vertical fija con una bolita (thumb).
     - Aplica una capa oscura + estilos visuales.
     - Incluye sonido al alternar.
     =========================================================================== */
  (function(){

    /* -------------------------------------------------------------------------
       REFERENCIAS AL DOM
       ------------------------------------------------------------------------- */

    const handle   = document.getElementById('rightHandle'); // Contenedor fijo de toda la tirita
    const track    = document.getElementById('rightTrack');  // Riel vertical clickeable
    const thumb    = document.getElementById('modeThumb');   // Bolita sol/luna
    const overlay  = document.getElementById('dimOverlay');  // Capa de oscurecido de la página

    // Seguridad: si falta algún elemento crítico, abortamos todo el bloque
    if (!handle || !track || !thumb || !overlay) return;

    /* -------------------------------------------------------------------------
       ICONOS SVG (INLINE) PARA LA BOLITA
       ------------------------------------------------------------------------- */

    // Icono de Sol (modo día)
    const ICON_SUN =
      '<svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor" aria-hidden="true">' +
      '<path d="M6.76 4.84l-1.8-1.79L3.17 4.84l1.79 1.79 1.8-1.79zM1 13h3v-2H1v2zm10 10h2v-3h-2v3zm9-10v-2h-3v2h3zm-2.93 7.07l1.79 1.79 1.79-1.79-1.79-1.79-1.79 1.79zM12 6a6 6 0 100 12 6 6 0 000-12zm7.24-1.16l-1.8-1.79-1.79 1.79 1.79 1.79 1.8-1.79zM4.84 17.24l-1.79 1.79 1.79 1.79 1.79-1.79-1.79-1.79z"/>' +
      '</svg>';

    // Icono de Luna (modo noche)
    const ICON_MOON =
      '<svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor" aria-hidden="true">' +
      '<path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/>' +
      '</svg>';

    /* -------------------------------------------------------------------------
       SONIDO DEL INTERRUPTOR (CLICK DE LA TIRITA)
       ------------------------------------------------------------------------- */

    // Construye la URL del sonido respetando subcarpetas (local / GitHub Pages)
    const SWITCH_URL = asset('light_switch.mp3');

    const switchSfx = new Audio(SWITCH_URL); // Audio del interruptor
    switchSfx.preload = 'auto';              // Precarga el sonido
    switchSfx.volume = 0.7;                  // Volumen del efecto (0.0 a 1.0)
    switchSfx.playbackRate = 1.0;             // Velocidad normal

    // Reproduce el sonido del interruptor de forma segura
    function playSwitch() {
      try {
        switchSfx.currentTime = 0;            // Reinicia para permitir clics rápidos
        const p = switchSfx.play();           // Reproduce el sonido
        if (p && typeof p.catch === 'function') {
          p.catch(() => {});                  // Ignora bloqueos de autoplay
        }
      } catch (_) {
        // Error ignorado intencionalmente
      }
    }

    /* -------------------------------------------------------------------------
       ESTADO INTERNO
       ------------------------------------------------------------------------- */

    let oscuro = false; // false = Día (Sol), true = Noche (Luna)

    /* -------------------------------------------------------------------------
       APLICAR ESTADO VISUAL SEGÚN EL MODO
       ------------------------------------------------------------------------- */
    function aplicarEstado() {
      overlay.classList.toggle('activo', oscuro);          // Activa/desactiva oscurecido
      handle.classList.toggle('activo', oscuro);           // Cambia apariencia de la tirita
      document.body.classList.toggle('oscuro', oscuro);    // Estilos globales (barra música)
      thumb.setAttribute('aria-pressed', String(oscuro));  // Accesibilidad
      thumb.innerHTML = oscuro ? ICON_MOON : ICON_SUN;     // Icono correcto
    }

    /* -------------------------------------------------------------------------
       ANIMACIÓN BREVE DE “ESTIRAMIENTO” DEL RIEL
       ------------------------------------------------------------------------- */
    function estirarTirita() {
      track.classList.add('stretch');                       // Agrega clase animada
      setTimeout(() => track.classList.remove('stretch'), 230);
    }

    /* -------------------------------------------------------------------------
       CAMBIAR ENTRE MODO DÍA / NOCHE
       ------------------------------------------------------------------------- */
    function alternar() {
      oscuro = !oscuro;                                    // Invierte el estado
      aplicarEstado();                                     // Aplica cambios visuales
      estirarTirita();                                     // Animación del riel
      playSwitch();                                        // Sonido del interruptor
    }

    /* -------------------------------------------------------------------------
       EVENTOS DE INTERACCIÓN
       ------------------------------------------------------------------------- */

    // Click en el riel completo (excepto la bolita)
    track.addEventListener('click', (e) => {
      if (e.target === thumb) return; // Evita doble activación
      alternar();
    });

    // Click directo en la bolita
    thumb.addEventListener('click', (e) => {
      e.stopPropagation(); // Evita que el evento suba al riel
      alternar();
    });

    // Estado inicial al cargar: modo día
    aplicarEstado();

  })();


  /* ===========================================================================
     BLOQUEAR PROPORCIÓN SEGÚN EL PRIMER GIF
     - Lee el tamaño natural del <img> inicial.
     - Fija aspect-ratio en el contenedor .img-redondeada.
     - Evita saltos de layout al cambiar GIFs.
     - En móviles deja que el CSS (vh) mande.
     =========================================================================== */
  function lockAspectFrom(imgEl) {

    // Seguridad: si no hay imagen, salimos
    if (!imgEl) return;

    // Busca el contenedor del GIF
    const container = imgEl.closest('.img-redondeada');
    if (!container) return;

    // Función que aplica el comportamiento correcto
    const apply = () => {

      /* -----------------------------------------------------------------------
         MÓVILES: NO fijar aspect-ratio
         - El CSS define la altura con vh (ej: 72vh).
         ----------------------------------------------------------------------- */
      if (window.matchMedia('(max-width: 520px)').matches) {
        container.style.aspectRatio = '';    // Limpia ratio inline si existía
        setCover(imgEl);                      // Imagen cubre el contenedor
        return;
      }

      /* -----------------------------------------------------------------------
         ESCRITORIO: fijar aspect-ratio según el primer GIF
         ----------------------------------------------------------------------- */
      const w = imgEl.naturalWidth;           // Ancho real del GIF
      const h = imgEl.naturalHeight;          // Alto real del GIF
      if (!w || !h) return;                   // Seguridad

      container.style.height = '';            // Limpia height previo
      container.style.aspectRatio = `${w} / ${h}`; // Fija proporción
      setCover(imgEl);
    };

    // Si la imagen ya cargó, aplica de inmediato
    if (imgEl.complete) {
      apply();
    } else {
      // Si no, espera al evento load (una sola vez)
      imgEl.addEventListener('load', apply, { once: true });
    }
  }


  // Aplica el modo "cover" al <img> de forma consistente
  function setCover(imgEl) {
    if (!imgEl) return;
    imgEl.style.width = "100%";
    imgEl.style.height = "100%";
    imgEl.style.objectFit = "cover";
  }

  /* ===================================================================
    ROTADOR DE GIFs — V3 (PRO)
    - El primer GIF carga instantáneo
    - gifs.json se carga en background
    - Todos los GIFs se precargan
    - Cambio de GIF SIEMPRE instantáneo
    =================================================================== */
  function setupGifRotator(btn, imgEl) {
    if (!btn || !imgEl) return;

    let urls = [];
    let actual = 0;
    let ready = false;

    // Deshabilita el botón hasta que todo esté listo
    btn.disabled = true;
    btn.style.opacity = "0.5";

    // Carga la lista en background (no bloquea render)
    fetch(asset("gifs.json"), { cache: "no-store" })
      .then(r => r.ok ? r.json() : Promise.reject())
      .then(files => {
        if (!Array.isArray(files) || files.length === 0) return;

        urls = files.map(f => asset(f));

        // Detectar GIF actual
        const current = new URL(imgEl.getAttribute("src"), location.href).href;
        const idx = urls.indexOf(current);
        actual = idx >= 0 ? idx : 0;

        // 🔥 PRE-CARGA REAL
        urls.forEach((url) => {
          const img = new Image();
          img.src = url;
        });

        ready = true;
        btn.disabled = false;
        btn.style.opacity = "1";
      })
      .catch(() => {
        console.warn("GIF rotator: gifs.json no disponible");
      });

    // Click → siguiente GIF (solo si está listo)
    btn.addEventListener("click", () => {
      if (!ready || urls.length === 0) return;

      actual = (actual + 1) % urls.length;
      imgEl.src = urls[actual];
      setCover(imgEl);
    });
  }



  /* ===========================================================================
     AJUSTE AUTOMÁTICO DEL TÍTULO A UNA SOLA LÍNEA (VERSIÓN SUAVIZADA)
     - Escala el título horizontalmente para que nunca haga salto de línea.
     - Ajusta dinámicamente la altura del contenedor.
     - Usa ResizeObserver + requestAnimationFrame para rendimiento suave.
     - Se desactiva en embeds de Notion.
     =========================================================================== */
  (() => {
    try {

      /* -----------------------------------------------------------------------
         SALIDA TEMPRANA PARA NOTION EMBED
         ----------------------------------------------------------------------- */
      if (document.documentElement.classList.contains('embed-notion')) return;

      /* -----------------------------------------------------------------------
         REFERENCIAS AL DOM
         ----------------------------------------------------------------------- */
      const root  = document.documentElement;             // <html> (clases globales)
      const wrap  = document.querySelector('.title-wrap'); // Contenedor del título
      const title = document.getElementById('pageTitle');  // <h1> principal
      if (!wrap || !title) return;                         // Seguridad

      /* -----------------------------------------------------------------------
         VARIABLES DE CONTROL Y CACHÉ
         ----------------------------------------------------------------------- */
      let rafId = 0;            // ID del requestAnimationFrame activo

      let lastAvail  = NaN;     // Último ancho disponible medido
      let lastScale  = NaN;     // Última escala aplicada
      let lastSpacing = NaN;    // Última separación entre letras aplicada
      let lastHeight = NaN;     // Última altura aplicada al contenedor
      let lastFull   = null;    // Último estado fullscreen (browser-fullscreen)

      /* -----------------------------------------------------------------------
         CÁLCULO Y APLICACIÓN DEL ESCALADO
         ----------------------------------------------------------------------- */
      function computeAndApply() {
        rafId = 0;                                  // Libera el RAF actual

        const avail = wrap.clientWidth || 0;        // Ancho disponible
        const isFull = root.classList.contains('browser-fullscreen');

        // Evita recalcular si el ancho no cambió y el modo no cambió
        const modeUnchanged = lastFull !== null && isFull === lastFull;
        if (modeUnchanged && isFinite(lastAvail) && Math.abs(avail - lastAvail) < 1) return;
        lastAvail = avail;
        lastFull = isFull;

        // Medida base sin letter-spacing para calcular expansión sin distorsión
        const prevLetter = title.style.letterSpacing;
        title.style.letterSpacing = '0px';
        const base = title.scrollWidth || 1;        // Ancho real del texto (sin spacing)
        title.style.letterSpacing = prevLetter;
        if (!isFinite(base)) return;

        const textLen = (title.textContent || '').length;
        const gaps = Math.max(1, textLen - 1);

        let spacing = 0;
        let scale = 1;
        let origin = 'left top';

        if (avail >= base) {
          // En fullscreen, abrimos con letter-spacing y luego ajustamos con un scale leve
          if (isFull) {
            const neededSpacing = (avail - base) / gaps;
            const spacingWeight = 0.45; // reparte expansión entre spacing y scale
            const maxSpacing = 3.5; // px: evita separación excesiva
            spacing = Math.min(maxSpacing, Math.max(0, neededSpacing * spacingWeight));

            const expanded = base + spacing * gaps;
            if (expanded > 0 && expanded < avail) {
              const maxExpandScale = 1.18; // expansión leve, sin deformar demasiado
              scale = Math.min(maxExpandScale, avail / expanded);
              if (scale > 1) origin = 'center top';
            }
          }
        } else {
          // Si no cabe, reducimos con scaleX (no hay alternativa sin romper línea)
          spacing = 0;
          scale = Math.max(0.25, avail / base);
        }

        // Solo aplica si el cambio es perceptible
        if (!isFinite(lastScale) || Math.abs(scale - lastScale) > 0.005 || Math.abs(spacing - lastSpacing) > 0.25) {
          title.style.letterSpacing = spacing ? `${spacing}px` : '0px';
          title.style.transformOrigin = origin;
          title.style.transform = `scaleX(${scale})`;
          lastScale = scale;
          lastSpacing = spacing;

          // Ajusta la altura del wrapper según el título escalado
          const h = title.getBoundingClientRect().height;
          if (!isFinite(lastHeight) || Math.abs(h - lastHeight) > 0.5) {
            wrap.style.height = h + 'px';
            lastHeight = h;
          }
        }
      }

      /* -----------------------------------------------------------------------
         PLANIFICACIÓN SUAVIZADA DEL RECÁLCULO
         ----------------------------------------------------------------------- */
      function schedule() {
        if (rafId) return;                       // Evita múltiples RAF simultáneos
        rafId = requestAnimationFrame(computeAndApply);
      }

      /* -----------------------------------------------------------------------
         OBSERVADORES DE CAMBIO DE TAMAÑO
         ----------------------------------------------------------------------- */
      if (typeof ResizeObserver !== 'undefined') {
        const ro = new ResizeObserver(schedule); // Observa cambios de tamaño
        ro.observe(wrap);
      }

      window.addEventListener('resize', schedule, { passive: true }); // Fallback
      document.addEventListener('fullscreenchange', schedule);        // API fullscreen

      // Si cambia la clase en <html>, recalcula (ej: F11 detectado por script)
      if (typeof MutationObserver !== 'undefined') {
        const mo = new MutationObserver(() => schedule());
        mo.observe(root, { attributes: true, attributeFilter: ['class'] });
      }

      // Primera ejecución inicial
      schedule();

    } catch (err) {
      console.error('Title fit error:', err); // Log defensivo
    }
  })();
</script>


<script>
const   foo = 1
</script>


